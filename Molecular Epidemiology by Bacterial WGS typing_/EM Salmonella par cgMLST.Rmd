---
title: "Epideiologie moleculaire Salmonella par cgMLST"
author: "Serigne Fallou MBacke NGOM"
date: "2024-01-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F)
```

On utilise des données cgMLST pour effectuer une analyse rétrospective sur un ensemble de données comprenant un certain nombre d'épidémies possibles de Salmonella enterica. 

L’ensemble de données sur l’épidémie se compose de données WGS provenant d’isolats récupérés à partir d’échantillons collectés dans un large éventail de régions géographiques, d’environnements et de délais pouvant remonter au début des années 2000.

Notre défi sera d'exploiter les outils et les données à notre disposition pour établir des profils cgMLST de haute qualité pouvant être utilisés pour déduire une parenté génétique et explorer des modèles dans les données afin de synthétiser les interprétations possibles basées sur toutes les données génomiques et épidémiologiques disponibles.   

Pour commencer, vous disposez d'appels d'allèles cgMLST précalculés générés par chewBBACA ( Silva et al. 2018 , en utilisant un schéma génomique de base de Salmonella basé sur 3 000 locus.

Le modèle de code suivant a été utilisé pour appeler chewBBACA sur un ensemble de génomes de Salmonella consolidés dans un seul répertoire appelé/path/to/my_genomes :

> chewBBACA.py AlleleCall -i /path/to/my_genomes/ -g /path/to/cgMLST_scheme/ -o /path/to/results```

# Importer les données et métadonnées cgMLST

## Ensemble de données d'analyse
L'ensemble de données du laboratoire du module 5 a été téléchargé sur Google Sheets :
1.  [Metadata](https://docs.google.com/spreadsheets/d/12gvH6U5pwj8QK-Ui3lOIYOm_X-69A2IE0cbctaEzY5E/edit?usp=sharing#gid=1448009352)
2.  [cgMLST data](https://docs.google.com/spreadsheets/d/12gvH6U5pwj8QK-Ui3lOIYOm_X-69A2IE0cbctaEzY5E/edit?usp=sharing#gid=8240612)


```{r load pkgs and helper scripts}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(treedataverse))
suppressPackageStartupMessages(library(plotly))
suppressPackageStartupMessages(library(ggnewscale))
suppressPackageStartupMessages(library(ComplexHeatmap))
suppressPackageStartupMessages(library(circlize))
suppressPackageStartupMessages(library(randomcoloR))
suppressPackageStartupMessages(library(RColorBrewer))
suppressPackageStartupMessages(library(phangorn))
suppressPackageStartupMessages(library(knitr))
source("src/mlst_helper.R")
source("src/ggtree_helper.R")
source("src/cluster_helper.R")
```


```{r load data}
# data paths
metadata_path <- "data/senterica_metadata_final.tsv"
cgmlst_path <- "data/senterica_cgMLST_full.tsv"
# read file
meta <- fread(metadata_path, sep = "\t", colClasses = "character")
cgmlst <- fread(cgmlst_path, sep = "\t")
```

# cgMLST QC

Avant d'aller plus loin, nous évaluons d'abord la qualité des données cgMLST. Il faut veiller à éviter les comparaisons incluant des loci et des génomes avec un nombre excessif d'allèles non attribués, ce qui pourrait réduire la précision des calculs de similarité génétique à utiliser pour générer des dendrogrammes permettant de déduire des relations entre les différents génomes de l'ensemble de données.

<img src="https://raw.githubusercontent.com/bioinformaticsdotca/IDE_2023/main/module5/img/mlst_qc_flowchart.jpg" width="750"/>

## Qualité des Locus

```{r compute loci completeness}
# use compute_lc helper function to compute allele assignment rate (completeness) across all loci
loci_completeness <- compute_lc(cgmlst)
# write to file
write.table(loci_completeness, "cgmlst_loci_quality.stats.tsv",
            quote = F, row.names = F, sep = "\t")
# print summary statistics for locus completeness
summary(loci_completeness)
```


```{r low assignment loci}
##### EDITABLE VARIABLE #####
lqual_threshold <- 2
#############################

# identify low qual loci
lqual_loci <- loci_completeness %>% 
  filter(missing_alleles > lqual_threshold) %>% 
  pull(locus)
# remove low qual loci from input cgMLST data
cgmlst_lc <- cgmlst %>% select(-all_of(lqual_loci))
# write to file
write.table(cgmlst_lc, "cgmlst_lqual_loci_rm.tsv",
            quote = F, row.names = F, sep = "\t")
# print filtering results
message(paste("Number of loci before filter:", ncol(cgmlst)-1))
message(paste("Number of loci after filter:", ncol(cgmlst_lc)-1))
message(paste("Number of loci removed:", ncol(cgmlst)-ncol(cgmlst_lc)))
message(paste0("Loci with ", lqual_threshold, " or less missing alleles were retained"))
```

## Definir Core Genes

```{r identify core loci}
##### EDITABLE VARIABLE #####
core_threshold <- 1
genome_qual <- 27
#############################

# compute core loci
core_loci <- calculate_core(
  mlst = cgmlst_lc,
  core_threshold = core_threshold,
  genome_qual = genome_qual
)
```

## Qualité du génome

```{r genome completeness}
# compute genome completeness given quality filtered scheme
genome_completeness <- cgmlst_lc %>% 
  select(1, all_of(core_loci)) %>% 
  compute_gc()
# write to file
write.table(genome_completeness, "cgmlst_genome_qual.stats.tsv",
            quote = F, row.names = F, sep = "\t")
# print data summary of genome completeness
summary(genome_completeness)
```

```{r low assignment genomes}
##### EDITABLE VARIABLE #####
lqual_g_threshold <- 26
#############################

# identify low qual genomes
lqual_genomes <- genome_completeness %>% 
  filter(missing_alleles > lqual_g_threshold) %>% 
  pull(ID)
# remove low qual genomes from quality filtered cgmlst
cgmlst_final <- cgmlst_lc %>% 
  filter(!(`#Name` %in% lqual_genomes)) %>% 
  select(1, all_of(core_loci))
# remove low qual genomes from metadata
metadata <- meta %>% filter(!(ID %in% lqual_genomes))
# write to file
write.table(cgmlst_final, "cgmlst_final.tsv",
            quote = F, row.names = F, sep = "\t")
# print filtering results
message(paste("Number of genomes before filter:", nrow(cgmlst_lc)))
message(paste("Number of genomes after filter:", nrow(cgmlst_final)))
message(paste("Number of genomes removed:", nrow(cgmlst_lc)-nrow(cgmlst_final)))
message(paste0("Genomes with ", lqual_g_threshold, " or less missing alleles were retained"))
```

# Distance de Hamming
Les méthodes basées sur la distance peuvent être utilisées pour construire des dendrogrammes à partir de données cgMLST. En analyse phylogénétique, les approches basées sur la distance sont plutôt flexibles dans le sens où elles peuvent être construites à partir de n'importe quelle mesure quantifiant la similarité génétique, y compris les distances calculées par des algorithmes de recherche de similarité sans alignement (par exemple Mash) ou basés sur l'alignement (par exemple BLAST). 

Étant donné deux vecteurs de caractères de longueurs égales, la distance de Hamming est le nombre total de positions dans lesquelles les deux vecteurs sont différents :
Profile A: `[ 0 , 2 , 0 , 5 , 5 , 0 , 0 , 0 , 0 ]`

Profile B: `[ 0 , 1 , 0 , 4 , 3 , 0 , 0 , 0 , 0 ]`

  A != B: `[ 0 , 1 , 0 , 1 , 1 , 0 , 0 , 0 , 0 ]`

Hamming distance = `sum( A != B )` = 3


```{r calculate hamming distance}
dist_mat <- cgmlst_final %>% 
  column_to_rownames("#Name") %>% 
  t() %>% 
  hamming()
# print matrix dimension the dimension should be symmetric!
dim(dist_mat)
```

Dans le contexte de deux profils cgMLST, la distance de Hamming peut être calculée sur la base du nombre de différences alléliques sur tous les loci. Les distances de Hamming seront calculées de manière tout contre tout pour générer une matrice de distance par paire qui servira d'entrée pour les algorithmes de construction d'arbres basés sur la distance tels que UPGMA et Neighbour-joining. Nous visualiserons les modèles de clustering dans la matrice de distance à l'aide du package ComplexHeatmap. Nous superposerons également les informations sur les sérovars pour examiner les distances inter et intra-sérovars.

```{r distance matrix viz}
# create column annotations for heatmap to display serovar information
heatmap_annot <- metadata$serovar
names(heatmap_annot) <- metadata$ID
heatmap_annot <- heatmap_annot[order(factor(names(heatmap_annot),
                                            levels = rownames(dist_mat)))]
# create heatmap
dist_mat %>% 
  Heatmap(
    name = "cgMLST\nDistance",
    show_row_names = F, # do not display row labels
    show_column_names = F, # do not display column labels
    # use custom color gradient
    col = colorRamp2(
      c(min(dist_mat), mean(dist_mat), max(dist_mat)),
      c("#7ece97", "#eebd32", "#f76c6a")
    ),
    # add column annotation to show serovar info
    top_annotation = HeatmapAnnotation(
      Serovar = heatmap_annot,
      col = list(
					"Serovar" = structure(brewer.pal(length(unique(heatmap_annot)), "Set1"),
																names = unique(heatmap_annot))
      )
    )
  )
```

# Construction du dendrogramme
Ici, nous allons construire un arbre de jonction de voisins (NJ) en utilisant la nj()fonction du package ape. 

## Une simple vue d'arbre
Pour commencer, exécutons le morceau de code suivant pour tracer une arborescence circulaire de l’ensemble de données avec les pointes de l’arbre colorées par les informations du sérotype.

```{r core genome tree}
##### EDITABLE VARIABLE #####
color_var <- "serovar"
#############################

# set random seed
set.seed(123)
# determine category count in the color aes variable
n_colors <- length(unique(pull(metadata, !!sym(color_var))))
# construct a core genome tree using nj algorithm
cg_tree <- distance_tree(
  matrix = dist_mat,
  method = "nj"
)
# plot core genome tree and colouring the tree tips by color_var
cg_tree_p <- cg_tree %>% 
  ggtree(layout = "circular",
         size = 0.75) %<+% metadata +
  geom_tippoint(aes(color = !!sym(color_var)),
                size = 2) +
  guides(color = guide_legend(override.aes = list(size = 3) ) ) +
  scale_color_manual(values = distinctColorPalette(n_colors))
# print tree plot object
cg_tree_p
```
Oranienburg - il est paraphylétique. Un clade monophylétique correspond aux membres d'une unité taxonomique (par exemple, un sérovar) partageant un ancêtre commun, et tous les descendants de cet ancêtre appartiennent à la même unité taxonomique. Un clade paraphylétique correspond aux membres d'une unité taxonomique (par exemple, un sérovar) partageant un ancêtre commun, mais tous les descendants de cet ancêtre n'appartiennent pas à la même unité taxonomique. Un clade polyphylétique correspond aux membres d'une unité taxonomique (par exemple, un sérovar) descendant de différents ancêtres.


## Regroupement par distance

L'identification de groupes de génomes partageant des profils cgMLST très similaires grâce à l'application de seuils de distance est une pratique courante dans la surveillance génomique et les enquêtes épidémiologiques. 
La détection de nouveaux clusters, comprenant des isolats d'agents pathogènes provenant de cas cliniques humains, peut signaler l'émergence d'une épidémie nécessitant une réponse de santé publique et peut fournir des informations épidémiologiques importantes sur la progression de l'épidémie. De même, le regroupement des isolats d’épidémie avec des isolats provenant de sources alimentaires/environnementales peut aider à relier l’épidémie à d’éventuelles sources/réservoirs de l’agent pathogène afin d’éclairer les mesures de prévention et de contrôle.

Dans cette section, nous générerons des clusters génomiques à partir de l’ensemble de données en appliquant plusieurs seuils de distance. Nous placerons ensuite les clusters dans le dendrogramme et analyserons les appartenances aux clusters pour repérer d'éventuelles épidémies dans l'ensemble de données.
```{r cluster by distance, results = 'hide'}
# define clustering distance cutoffs
dist_cutoff <- c(0, seq(5, 100, 5), seq(200, 1000, 100))
# perform complete linkage clustering
hclust_res <- map(dist_cutoff, function(x) {
  dist_mat %>% 
    as.dist() %>% 
    hclust(method = "complete") %>% 
    cutree(h = x) %>% 
    as.factor()
})
names(hclust_res) <- paste0("clust_", dist_cutoff)
# print clustering results table
(
  clusters <- data.frame(hclust_res) %>% 
    rownames_to_column("ID")
  )
```

> Vous pouvez mettre à jour la target_thresholdvariable pour examiner comment l'appartenance au cluster change en réponse aux limites de distance de clustering.

```{r cg tree cluster viz}
### EDITABLE VARIABLE ###
target_threshold <- 500
#########################

# variable to subset clusters
target_variable <- paste0("clust_", target_threshold)

# create cluster group list object
cluster_grp <- clusters %>% 
  select(ID, target_variable) %>%
  group_by(!!sym(target_variable)) %>% 
  {setNames(group_split(.), group_keys(.)[[1]])} %>% 
  map(~pull(., ID))
# sequester singleton clusters
cluster_grp <- cluster_grp[which(map_dbl(cluster_grp, ~length(.)) > 1)]

# create serovar group list object
serovar_grp <- metadata %>% 
  select(ID, serovar) %>% 
  split(f = as.factor(.$serovar)) %>% 
  map(~pull(., ID))

# add cluster memberships and serovar information to tree object
cg_tree <- groupOTU(cg_tree, cluster_grp, 'Clusters')
cg_tree <- groupOTU(cg_tree, serovar_grp, 'Serovars')

# plot core genome tree where colored blocks = clusters text annotations = serovars
cg_tree %>% 
  ggtree(layout='circular', # tree shape
         size = 1 # branch width
  ) +
  # add colored blocks to display serovars
  geom_hilight(
    mapping = aes(
      node = node,
      fill = Serovars,
      subset = node %in% map_dbl(
        serovar_grp,
        ~getMRCA(cg_tree, .)
        )
      )
    ) +
  # add text annotations to display clusters
  geom_cladelab(
    mapping = aes(
      node = node,
      label = Clusters,
      subset = node %in% map_dbl(
        cluster_grp,
        ~getMRCA(cg_tree, .)
      )
    ),
    horizontal=T,
    angle = 'auto',
    barsize = 0.75,
    offset = 50,
    offset.text = 50,
    align = T
  ) +
  # legend parameters
  guides(fill = guide_legend(
    nrow = 9,
    override.aes = list(alpha = 0.8)
    )
  ) +
  labs(fill = "Serovar") +
  scale_fill_brewer(palette = "Paired")
```
Oranienburg - il est paraphylétique. Un clade monophylétique correspond aux membres d'une unité taxonomique (par exemple, un sérovar) partageant un ancêtre commun, et tous les descendants de cet ancêtre appartiennent à la même unité taxonomique. Un clade paraphylétique correspond aux membres d'une unité taxonomique (par exemple, un sérovar) partageant un ancêtre commun, mais tous les descendants de cet ancêtre n'appartiennent pas à la même unité taxonomique. Un clade polyphylétique correspond aux membres d'une unité taxonomique (par exemple, un sérovar) descendant de différents ancêtres.

## L'analyse par Cluster
Afin d'analyser les modèles de regroupement dans l'arbre génomique principal à de plus grandes résolutions, nous travaillerons avec un certain nombre de fonctions R présentées ci-dessous. Ces fonctions sont destinées à être utilisées conjointement pour zoomer sur des populations bactériennes spécifiques dans l'ensemble de données, ce qui nous permettrait d'explorer la clonalité et l'épidémiologie des souches cibles.


### serovar_subtree
Le but de la fonction serovar_subtreeest d’analyser les sous-arbres de sérotypes spécifiques. Le sérotype cible à examiner est défini par la serovar_namevariable. Spécifier une valeur NULL pour la variable affichera l’intégralité de l’arborescence.
```{r serovar subtree, fig.height = 15, fig.show = 'hide', message = F}
# NOTE: there needs to be a comma at the end of each line!
serovar_subtree(
  tree = cg_tree,
  serovar_name = NULL, # which serovar cluster to visualize?
  distance_threshold = 10, # the dist threshold used for cluster definition?
  color_by = "serovar", # which metadata variable to color tree tips by?
  color.tiplab = F, # whether to color tip labels
  tip.size = 4, # size of tree tip point
  label_vars = c("geo_loc", "iso_date", "iso_source"), # metadata vars only
  label.offset = 80, # distance between labels and tree tips
  label.size = 5, # tree tip label text size
  legend.x = 0.23, # legend position on x axis
  legend.y = 0.9, # legend position on y axis
  legend.size = 6, # legend text size
  legend.ncat.per.col = 8, # number of categories to show per column in legend
  hide.legend = F, # whether to hide colour legend
  plot.xlim = 2300, # plot area width
  annot.offset = 3, # distance between heatmap and tree tips
  annot.textsize = 5, # heatmap x axis text label size
  annot.barsize = 0.75, # annotation bar width
  show.title = T # whether to display distance threshold
)
# export tree to pdf format
ggsave("serovar_subtree.pdf", height = 30, width = 16)
```

- Les isolats du Cluster 23 proviennent d'Australie le 26 février 2012 ; Les isolats du Cluster 26 proviennent d'Australie le 23 avril 2012 ; Le Cluster 49 provient des États-Unis : MN en mai 2001 et juin 2001: forment un cluster génomique regroupant des cas cliniques humains avec des informations géographiques et temporelles similaires.

- Le Cluster 10 comprend des isolats de CO, GA, TX, CA, MN et quelques isolats avec un état non défini ; Le Cluster 25 comprend des isolats du CT, NJ et MN: forment Un cluster génomique dans lequel les cas cliniques humains sont dispersés géographiquement et/ou dans le temps.

- Cluster 23 (humain avec mayonnaise aux œufs crus) ; Cluster 41 (humain avec amande crue): Un cluster génomique dans lequel les isolats cliniques humains se regroupent avec des isolats non humains d'un type de source particulier.

- Cluster 13 - Isolats humains regroupés avec différentes sources liées aux noix: Un cluster génomique dans lequel les isolats cliniques humains se regroupent avec des isolats non humains de plusieurs types de sources.

- Des clusters non apparentés (c'est-à-dire des clusters trouvés dans différentes parties de l'arbre) avec des isolats partageant des données épidémiologiques presque identiques, ce qui indiquerait une épidémie polyclonale. Les clusters de pistaches (Clusters 13, 5, 18 à T10) constitués d'isolats de Senftenberg et de Montevideo sont en fait liés à la même épidémie: Des génomes de différents clusters génomiques identifiés dans une seule épidémie putative pouvant être liés à une source commune.

### cluster_subtree
Le but de la fonction cluster_subtreeest d'analyser des sous-arbres de clusters spécifiques définis à un seuil de distance donné. Un cluster est défini par son ID et le seuil de distance utilisé pour l'affectation, qui sont définis respectivement par les variables cluster_nameet distance_threshold.
```{r cluster subtree, fig.height = 6, message = F}
cluster_subtree(
  tree = cg_tree,
  clusters = clusters,
  distance_threshold = 25, # the dist threshold used for cluster definition?
  cluster_name = "1", # cluster ID to visualize?
  color_by = "country", # which metadata variable to color tree tips by?
  color.tiplab = F, # whether to color tip labels
  tip.size = 3, # size of tree tip point
  legend.x = 0.1, # legend position on x axis
  legend.y = 0.85, # legend position on y axis
  legend.size = 5, # legend text size
  legend.ncat.per.col = 8, # number of categories to show per column in legend
  hide.legend = F, # whether to hide colour legend
  plot.xlim = 30, # plot area width
  label_vars = c("country", "iso_date", "iso_source"), # metadata vars only
  label.offset = 5.5, # distance between labels and tree tips
  label.size = 4, # tree tip label text size
  annot.offset = 0.1, # distance between heatmap and tree tips
  annot.width = 0.4, # heatmap width
  annot.textsize = 4, # heatmap x axis text label size
  annot.nthreshold = 6 # number of clustering thresholds to display
)
```


### cluster_summary
Le but de la fonction cluster_summaryest de comparer la répartition des données catégorielles dans les métadonnées entre des clusters définis à un seuil de distance. Par exemple, ces comparaisons peuvent fournir un résumé global des sources putatives d’origine et de répartition géographique de chaque groupe génomique.
```{r intercluster analysis}
cluster_summary(
  distance_threshold = 10, # the dist threshold used for cluster definition?
  serovar_name = NULL, # which serovar to include?
  vars = c("geo_loc","iso_source", "iso_date_ym"), # metadata vars only
  panel.ncol = 1, # number of columns to arrange the panels in
  rm.low.freq.clust = T, # whether to remove low frequency (N < 4) clusters
  interactive = T # whether to generate interactive plots
)
```

## Investigations sur les gènes centraux locaux

```{r local core gene tree, message = F}
# identify a local core genome scheme for a target cluster and build tree
local_tree <- local_cg_tree(
  core_mlst = cgmlst_final,
  full_mlst = cgmlst_lc,
  distance_threshold = 100, # the dist threshold used for cluster definition?
  cluster_name = "10", # cluster ID to analyze?
  core_threshold = 1, # minimum number of missing alleles allowed
  method = "nj" # tree method: nj or upgma
)
# perform complete linkage clustering
hclust_res_local <- map(dist_cutoff, function(x) {
  cophenetic.phylo(local_tree) %>% 
    as.dist() %>% 
    hclust(method = "complete") %>% 
    cutree(h = x) %>% 
    as.factor()
})
names(hclust_res_local) <- paste0("clust_", dist_cutoff)
# create clusters data frame
clusters_local <- data.frame(hclust_res_local) %>% 
    rownames_to_column("ID")
```

```{r plot local cg tree, fig.height = 6, message = F}
plot_subtree(
  tree = local_tree,
  clusters = clusters_local,
  color_by = "country", # which metadata variable to color tree tips by?
  color.tiplab = F, # whether to color tip labels
  tip.size = 3, # size of tree tip point
  legend.x = 0.15, # legend position on x axis
  legend.y = 0.85, # legend position on y axis
  legend.size = 5, # legend text size
  legend.ncat.per.col = 8, # number of categories to show per column in legend
  hide.legend = F, # whether to hide colour legend
  plot.xlim = 150, # plot area width
  label_vars = c("country", "iso_date", "iso_source"), # metadata vars only
  label.offset = 25, # distance between labels and tree tips
  label.size = 4, # tree tip label text size
  annot.offset = 0.1, # distance between heatmap and tree tips
  annot.width = 0.3, # heatmap width
  annot.textsize = 4, # heatmap x axis text label size
  annot.nthreshold = 6 # number of clustering thresholds to display
)
```


